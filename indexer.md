# Database Indexer for Embedded KV Databases like RocksDB or LevelDB

## Overview

This document outlines the development of a database indexer that interfaces with any embedded key-value (KV) database, such as RocksDB or LevelDB. The indexer is designed to accept key-value entries where both keys and values are byte arrays. It ensures that all entries are lexicographically sorted by their keys.

### Objective

- Develop an indexer that can efficiently interact with embedded KV databases.
- Ensure the indexer supports various functionalities including indexing and sorting/filtering by different column types.

## Features

The database indexer should support the following key features:

1. *Accept Key-Value Entries*: The indexer must accept entries where both keys and values are byte arrays.
2. *Lexicographical Sorting*: All entries must be sorted lexicographically by their keys.

Additionally, the indexer must support the following functionalities:

- *Index by String Column*: Allow indexing of entries based on a string column.
- *Index by Number Column*: Allow indexing of entries based on a number column.
- *Sort/Filter by String Column*: Provide functionality to sort or filter entries by a string column.
- *Sort/Filter by Number Column*: Provide functionality to sort or filter entries by a number column.

The keys generated by the database indexer must be designed to enable O(1) database lookups by either string or number columns.

## Example Tabular Data Generation

To test and demonstrate the functionality of the database indexer, generate example tabular data with both string and number columns. This data will be used to verify that the indexer can properly index, sort, and filter entries based on the content of specific columns.

## Bonus Features

- *Tests (Quickcheck/Fuzz)*: Implement testing strategies such as Quickcheck or fuzz testing to ensure the reliability and robustness of the indexer.
- *Concurrency*: Ensure that the indexer supports concurrent operations, allowing for efficient data handling in multi-threaded environments.

## Implementation Language

The database indexer challenge is to be implemented using the Rust programming language. Rust's safety and concurrency features make it an ideal choice for developing a robust and efficient database indexer.